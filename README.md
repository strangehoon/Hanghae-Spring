# 📝 요구 사항(~ 3주차)
<details>
<summary>접기/펼치기</summary>

1. 회원 가입 API
    - username, password를 Client에서 전달받기
    - username은  `최소 4자 이상, 10자 이하이며 알파벳 소문자(a~z), 숫자(0~9)`로 구성되어야 한다.
    - password는  `최소 8자 이상, 15자 이하이며 알파벳 대소문자(a~z, A~Z), 숫자(0~9), 특수문자`로 구성되어야 한다.
    - DB에 중복된 username이 없다면 회원을 저장하고 Client 로 성공했다는 메시지, 상태코드 반환하기
    - 회원 권한 부여하기 (ADMIN, USER) - ADMIN 회원은 모든 게시글, 댓글 수정 / 삭제 가능
    - 참고자료
        1. [https://mangkyu.tistory.com/174](https://mangkyu.tistory.com/174)
        2. [https://ko.wikipedia.org/wiki/정규_표현식](https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D)
        3. [https://bamdule.tistory.com/35](https://bamdule.tistory.com/35)
        
2. 로그인 API
    - username, password를 Client에서 전달받기
    - DB에서 username을 사용하여 저장된 회원의 유무를 확인하고 있다면 password 비교하기
    - 로그인 성공 시, 로그인에 성공한 유저의 정보와 JWT를 활용하여 토큰을 발급하고, 
    발급한 토큰을 Header에 추가하고 성공했다는 메시지, 상태코드 와 함께 Client에 반환하기
3. 전체 게시글 목록 조회 API
    - 제목, 작성자명(username), 작성 내용, 작성 날짜를 조회하기
    - 작성 날짜 기준 내림차순으로 정렬하기
    - 각각의 게시글에 등록된 모든 댓글을 게시글과 같이 Client에 반환하기
    - 댓글은 작성 날짜 기준 내림차순으로 정렬하기
    - 게시글/댓글에 ‘좋아요’ 개수도 함께 반환하기
4. 게시글 작성 API
    - ~~토큰을 검사하여, 유효한 토큰일 경우에만 게시글 작성 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
    - 제목, 작성자명(username), 작성 내용을 저장하고
    - 저장된 게시글을 Client 로 반환하기
5. 선택한 게시글 조회 API
    - 선택한 게시글의 제목, 작성자명(username), 작성 날짜, 작성 내용을 조회하기 
    (검색 기능이 아닙니다. 간단한 게시글 조회만 구현해주세요.)
    - 선택한 게시글에 등록된 모든 댓글을 선택한 게시글과 같이 Client에 반환하기
    - 댓글은 작성 날짜 기준 내림차순으로 정렬하기
    - 게시글/댓글에 ‘좋아요’ 개수도 함께 반환하기
6. 선택한 게시글 수정 API
    - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 수정 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
    - 제목, 작성 내용을 수정하고 수정된 게시글을 Client 로 반환하기
    - 게시글에 ‘좋아요’ 개수도 함께 반환하기
7. 선택한 게시글 삭제 API
    - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 삭제 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
    - 선택한 게시글을 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기
8. 댓글 작성 API
    - ~~토큰을 검사하여, 유효한 토큰일 경우에만 댓글 작성 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
    - 선택한 게시글의 DB 저장 유무를 확인하기
    - 선택한 게시글이 있다면 댓글을 등록하고 등록된 댓글 반환하기
9. 댓글 수정 API
    - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 수정 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
    - 선택한 댓글의 DB 저장 유무를 확인하기
    - 선택한 댓글이 있다면 댓글 수정하고 수정된 댓글 반환하기
    - 댓글에 ‘좋아요’ 개수도 함께 반환하기
10. 댓글 삭제 API
    - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 삭제 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
    - 선택한 댓글의 DB 저장 유무를 확인하기
    - 선택한 댓글이 있다면 댓글 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기
11. 예외 처리
    - 토큰이 필요한 API 요청에서 토큰을 전달하지 않았거나 정상 토큰이 아닐 때는 "토큰이 유효하지 않습니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
    - 토큰이 있고, 유효한 토큰이지만 해당 사용자가 작성한 게시글/댓글이 아닌 경우에는 “작성자만 삭제/수정할 수 있습니다.”라는 에러메시지와 statusCode: 400을 Client에 반환하기
    - DB에 이미 존재하는 username으로 회원가입을 요청한 경우 "중복된 username 입니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
    - 로그인 시, 전달된 username과 password 중 맞지 않는 정보가 있다면 "회원을 찾을 수 없습니다."라는 에러메시지와 statusCode: 400을 Client에 반환하기
    - 회원가입 시 username과 password의 구성이 알맞지 않으면 에러메시지와 statusCode: 400을 Client에 반환하기 </br> </br>

</details>

# 📈 ERD
<details>
<summary>접기/펼치기</summary>

<img src = "https://user-images.githubusercontent.com/117654450/220970739-365a079d-3520-4794-93ba-a96d0c7dc55d.png" height = "350px" width = "550px" allign = "left">


**Null or Not Null ?** </br>

 모든 컬럼들이 다 필요해 보이지만 확장성 있게 설계하기 위해 대체로 널 값을 허용했다. 예를 들어 user 테이블의 role은 어떻게 보면 not null이 되어야 한다고 생각할 수 있는데 특정 비즈니스 로직에서는 null이 허용될 수 있다. 따라서 db 테이블을 설계할 시 이러한 점을 유의해야한다. 

</details>

# 🧐 Problem
<details>
<summary>접기/펼치기</summary>
 
 나는 DTO를 공통 DTO안에 넣어서 이를 다시 ResponseEntity의 body에 넣어 사용했다. 하지만 이는 지나치게 DTO를 감쌌으므로 좋은 코드가 아니다. 클라이언트에 공통 DTO를 반환하던가 DTO를 ResponseEntity에 넣어 반환하는 방식을 사용하도록 하자.  </br> </br> 
> 아래 "기타"의 DTO 관리 참고

</details>

# 💡 Q and A
<details>
<summary>접기/펼치기</summary>

**1. 처음 설계한 API 명세서에 변경 사항이 있었나요?
  변경되었다면 어떤 점 때문일까요? 첫 설계의 중요성에 대해 작성해 주세요!**
* 처음 설계한 API 명세서와 비교할 때 변경 사항은 없었다. 처음 설계할 때 신경을 많이 썼기 때문이다. </br> </br>



**2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되셨나요?**

* 솔직히 테이블이 3개 밖에 없어서 도움이 많이 되지 않았다. 하지만 테이블이 많아지면 그에 따른 연관관계를 고려하기 복잡해지기 마련인데 ERD를 먼저 설계하면 한눈에 연관관계를 볼 수 있어서 개발 편의성을 크게 향상시켜줄 것이다. </br> </br>

**3. JWT를 사용하여 인증/인가를 구현했을 때의 장점은 무엇일까요?**

* 서버에 별도의 저장소가 불필요하므로 서버 자원을 절약할 수 있다
(쿠키/세션 방식은 서버에 session storage가 필요)
* 쿠키를 전달하지 않아도 되므로 쿠키를 사용함으로써 발생하는 취약점이 사라진다.
* 트래픽에 대한 부담이 적다. </br> </br>


**4. 반대로 JWT를 사용한 인증/인가의 한계점은 무엇일까요?**

* 토큰의 페이로드(PayLoad)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부담을 줄 수 있다.
* secret key 유출시 JWT 조작이 가능하다. </br> </br>


**5. 댓글이 달려있는 게시글을 삭제하려고 할 때 무슨 문제가 발생할까요? JPA가 아닌 Database 테이블 관점에서 해결 방법이 무엇일까요?**
* 게시글과 댓글 테이블은 1대n 관계를 맺고 있다. 여기서 만약 게시글을 삭제하면 참조 무결성 제약조건을 위반하게 된다. 쉽게 말하면 댓글 테이블의 게시글을 참조하는 외래키가 가리키는 값이 없어진다. RDBMS는 기본적으로 제약조건을 위반하지 않도록 설계되어 있으므로 삭제를 시도하면 에러가 터진다.
* RDBMS 관점에서 해결책은 제약조건을 수정해주면 된다. 제약 조건에는 ON DELETE NO ACTION(default), ON DELETE CASCADE, ON DELETE SET NULL, ON DELETE SET DEFAULT가 있으며 이 중에서 ON DELETE CASCADE를 지정해주면 삭제할 수 있다. </br> </br>

**6. 5번과 같은 문제가 발생했을 때 JPA에서는 어떻게 해결할 수 있을까요?**
* JPA의 영속성 전이를 이용한다. cascade = CascadeType.REMOVE를 추가하면 게시물을 삭제할 시 관련있는 댓글도 같이 삭제할 수 있다. </br> </br>



**7. IoC / DI에 대해 간략하게 설명해 주세요!**  
* IOC(제어의 역전) : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IOC)이라 한다. DI는 외부에서 주입해주므로 IOC이다.
* DI : 스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능으로, 객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 것을 뜻한다.</br> </br>

**8. Spring Security를 적용했을 때 어떤 점이 도움이 되셨나요?**
* Spring Security는 보안과 관련해서 체계적으로 많은 옵션을 제공해주기 때문에 개발자 입장에서는 일일이 보안 관련 로직을 작성하지 않아도 된다. 

**9. Spring Security를 사용하지 않는다면 어떻게 인증/인가를 효율적으로 처리할 수 있을까요?**
* jwt를 사용한다면 본인이 직접 필터를 구현해서 처리하면 된다. 하지만 생산성, 유지보수, 성능 등 모든 면에서 직접 구현하기보다는 스프링 시큐리티를 사용하는게 더 좋다.

**10. AOP에 대해 설명해 주세요!**
* AOP는 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍이라고 불린다. 관점 지향은 쉽게 말해 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다. 코드의 중복을 줄이고 유지 보수성이 좋아진다.

**11. RefreshToken 적용에 대한 장/단점을 작성해 주세요**
* 토큰은 서버 측 리소스에 접근할 때 클라이언트 본인을 인증할 수 있는 액세스 토큰으로 동작한다. 그런데 이 JWT는 Stateless한 방식이기 때문에 서버 측에서는 이 토큰을 갖고 있는 클라이언트가 정말 클라이언트 본인이 맞는지 확인할 수 없다. 이때 Refresh Token을 활용할 수 있다.
  * **장점** : 사용자가 Access Token이 탈취되더라도 짧은 유효기간이 지나면 사용할 수 없다. 즉 OTP 인증처럼 짧은 시간 동안에만 사용할 수 있도록 하고 주기적으로 재발급 받도록하여 토큰이 유출되어도 그 피해를 최소화 할 수 있다.
  * **단점** : 정상적인 클라이언트도 짧은 주기마다 다시 로그인해서 Access Token을 발급 받아야한다. 

**12. 즉시로딩 / 지연로딩에 대해 설명해 주세요!**
* **즉시로딩** : 특정 엔티티를 조회할 때 연관된 모든 엔티티를 같이 로딩하는 것을 즉시로딩이라한다. 연관된 엔티티를 모두 가져올 수 있지만 조인으로 인한 성능 저하와 N+1 문제가 발생할 수 있으므로 사용하지 않는게 좋다.
* **지연로딩** : 특정 엔티티를 조회할 때 연관된 모든 엔티티를 프록시 객체로 주입받는다. 따라서 성능저하나 N+1문제를 일으키지 않으며 실제 연관된 객체를 사용할 때 DB로 select 쿼리가 나간다. 모든 엔티티들은 기본적으로 지연로딩을 사용하는 것이 좋다. 

</details>

# 🚀 기타

<details>
<summary>접기/펼치기</summary>

### Swagger
Swagger를 사용해 API 문서를 자동화 했다.   </br> <br>

### RestFul API
마지막 과제에서 Restful API를 공부해보고 적용했다.
> 참고 : [RestFul API Naming](https://prohannah.tistory.com/156) </br></br>

### 스프링 네이밍 컨벤션
마지막 과제에서 스프링 네이밍 컨벤션에 따라 컨트롤러, 서비스단의 메서드 명을 수정했다. 
> 참고 : [스프링 네이밍 컨벤션](https://cocobi.tistory.com/27)


### DTO 관리
지금까지는 정영호 매니저님께서 이전 세션에서 알려주신 `@ResponseBody`를 사용해서 DTO를 관리했는데 마지막 과제에서 ResponseEntity를 사용해서 DTO를 관리했다. 둘 다 기능상 다를 바 없으나 ResponseEntity가 Http 메세지를 조금 더 세밀하게 다룰 수 있다. 이번 과제를 진행하면서 DTO 관리법에 대해 공부할 수 있었고 이를 개인 블로그에 정리했다.
> 블로그 포스팅 : [DTO 관리](https://velog.io/@strangehoon/%EA%B9%94%EA%B8%88%ED%95%98%EA%B2%8C-DTO-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0)

</details>
